<!DOCTYPE html>
<html>
<head>
    <title>Student Learning Portal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- CSS STYLING --- */
        /* Basic body setup: Dark background, white text, no scrolling on the main page */
        body { background: #050505; color: #fff; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        
        /* Custom Scrollbar Styling (makes scrollbars look modern/dark) */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #00ffcc; }

        /* Menu Container: Holds all the non-game screens (Login, Main Menu, Stats) */
        #menu-container { position: absolute; z-index: 100; background: rgba(0,0,0,0.98); width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        /* Screens are hidden by default. The 'active' class makes them flex (visible). */
        .screen { display: none; flex-direction: column; align-items: center; width: 100%; max-width: 900px; }
        .active { display: flex; }
        
        /* Text and Button Styles */
        h1 { font-size: 50px; margin-bottom: 20px; text-shadow: 0 0 20px rgba(0,255,204,0.3); letter-spacing: 3px; text-align: center; }
        .input-std { background: #222; border: 1px solid #444; color: #fff; padding: 12px; font-size: 18px; border-radius: 5px; margin: 5px 0; width: 300px; text-align: center; transition: 0.2s; }
        .input-std:focus { border-color: #00ffcc; outline: none; background: #333; }
        
        /* Buttons with hover effects */
        .btn { padding: 15px 40px; font-size: 18px; cursor: pointer; border: none; font-weight: bold; border-radius: 6px; margin: 10px; width: 280px; text-transform: uppercase; transition: 0.2s; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .btn-green { background: #00ffcc; color: #000; }
        .btn-zen { background: #a29bfe; color: #000; }
        .btn-apm { background: #ff5555; color: #fff; }
        .btn-ffa { background: #ff9900; color: #000; }
        .btn-blue { background: #00a8ff; color: #fff; }

        /* Layout for Main Menu (Split into user info on left, leaderboards on right) */
        #main-split { display: flex; flex-direction: row; gap: 50px; align-items: flex-start; margin-top: 20px; }
        .menu-left { display: flex; flex-direction: column; align-items: center; }
        .menu-right { width: 320px; background: #111; border: 1px solid #333; border-radius: 8px; padding: 15px; max-height: 500px; overflow-y: auto; }
        
        /* Stats Page Layout */
        #stats-layout { display: flex; width: 800px; height: 500px; background: #111; border: 1px solid #333; }
        #stats-list { width: 300px; border-right: 1px solid #333; overflow-y: auto; }
        #stats-detail { flex: 1; padding: 20px; overflow-y: auto; }
        .player-item { padding: 10px; cursor: pointer; border-bottom: 1px solid #222; display:flex; justify-content:space-between; font-family:monospace; font-size:12px; }
        .player-item:hover { background: #222; }

        /* Game Area Layout (Scaled down to fit screens) */
        /* v1.4 UPDATE: Adjusted scale to fit taller board */
        .game-area { display: flex; gap: 20px; transform: scale(0.9); transition: 0.5s; width: 100%; justify-content: center; align-items: center; }
        @media (max-height: 950px) { .game-area { transform: scale(0.75); } }
        
        .player-root { display: flex; flex-direction: column; align-items: center; }
        .player-container { display: flex; align-items: flex-start; gap: 10px; position: relative; }
        .main-board-wrap { position: relative; border: 4px solid #333; background: #000; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        
        /* Side Columns */
        .side-col { display: flex; flex-direction: column; width: 100px; gap: 10px; }
        .side-box { border: 2px solid #333; background: #000; display: flex; flex-direction: column; align-items: center; padding-top: 5px; color:#888; font-size:12px; min-height: 80px; justify-content: center; }
        
        /* v1.4 UPDATE: Increased height to match new ROWS count (30 * 30px = 900px) */
        .garbage-bar { width: 12px; height: 900px; background: #111; border: 1px solid #333; position: relative; overflow: hidden; }
        .garbage-fill { position: absolute; bottom: 0; width: 100%; background: #ff0033; transition: height 0.2s; }

        /* Overlays (Countdown, Results, etc.) */
        .overlay { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 150; display: flex; justify-content: center; align-items: center; flex-direction: column; pointer-events: none; }
        .hidden { display: none !important; }
        #cnt-txt { font-size: 120px; font-weight: 900; color: #fff; animation: pop 0.5s infinite alternate; }

        /* Floating Text Effects (Combo, B2B, Sent Lines) */
        .float-text { position: absolute; left: 50%; transform: translateX(-50%); font-weight: 900; opacity: 0; pointer-events: none; transition: 0.1s; text-align: center; width: 300px; text-shadow: 0 4px 8px rgba(0,0,0,0.9); font-style: italic; z-index: 50; }
        /* Translucent colors for text */
        .action-text { top: 250px; font-size: 36px; color: rgba(255,255,255,0.6); letter-spacing: 2px; }
        .combo-text { top: 200px; font-size: 28px; color: rgba(255,204,0,0.6); }
        .b2b-text { top: 160px; font-size: 18px; color: rgba(0,255,204,0.6); letter-spacing: 2px; }
        .sent-text { top: 300px; font-size: 50px; color: #ff0055; font-weight: 900; }

        /* Chat Styling */
        #chat-container { position: absolute; bottom: 20px; right: 20px; width: 300px; height: 250px; display: flex; flex-direction: column; z-index: 300; pointer-events: auto; }
        #chat-header { background: #222; padding: 5px; display: flex; justify-content: flex-end; }
        #chat-close { background: red; color: white; border: none; cursor: pointer; font-weight: bold; padding: 2px 8px; border-radius: 3px; }
        
        /* Stats Row at Top */
        .stats-row { display: flex; gap: 10px; margin-bottom: 10px; width: 100%; justify-content: center; }
        .stat-box { background: #111; border: 1px solid #333; padding: 5px 15px; border-radius: 4px; text-align: center; min-width: 70px; }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 1px; }
        .stat-val { font-size: 16px; font-weight: bold; color: #fff; font-family: monospace; }

        @keyframes pop { from { transform: scale(1); } to { transform: scale(1.1); } }
        canvas { display: block; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <button id="home-btn" class="hidden" onclick="goHome()">HOME</button>

    <div id="menu-container">
        <div id="scr-login" class="screen active">
            <h1>PROJECT <span style="color:#00ffcc">ASMONDY</span></h1>
            <input type="text" id="username" class="input-std" placeholder="USERNAME" maxlength="12" oninput="saveCreds()">
            <input type="password" id="password" class="input-std" placeholder="PASSWORD" oninput="saveCreds()">
            <button class="btn btn-green" onclick="attemptLogin()">LOGIN</button>
        </div>

        <div id="scr-main" class="screen">
            <h1>PROJECT <span style="color:#00ffcc">ASMONDY</span></h1>
            <div id="main-split">
                <div class="menu-left">
                    <div class="user-info">
                        Welcome, <span id="display-user">Guest</span><br>
                        Wins: <span id="display-wins" class="stat-highlight">0</span><br>
                        APM: <span id="display-apm" class="stat-highlight-apm">0</span>
                    </div>
                    <button class="btn btn-zen" onclick="startZen()">ZEN MODE</button>
                    <button class="btn btn-apm" onclick="startAPMTest()">APM TEST</button>
                    <button class="btn btn-ffa" onclick="joinFFA()">ONLINE FFA</button>
                    <button class="btn btn-blue" onclick="openStats()">STATS / HISTORY</button>
                    <button class="btn" style="background:#333; color:#aaa; font-size:14px;" onclick="logOut()">LOGOUT</button>
                </div>
                <div class="menu-right">
                    <h3>LEADERBOARD (WINS)</h3>
                    <div id="lb-wins" class="lb-list"><div style="text-align:center; color:#666;">Loading...</div></div>
                    <h3>LEADERBOARD (COMBO)</h3>
                    <div id="lb-combo" class="lb-list"><div style="text-align:center; color:#666;">Loading...</div></div>
                </div>
            </div>
        </div>

        <div id="scr-stats" class="screen">
            <h2 style="color:#00a8ff">STATISTICS</h2>
            <div id="stats-layout">
                <div id="stats-list"></div> <div id="stats-detail"><div style="text-align:center; color:#666; margin-top:50px;">Select a player.</div></div>
            </div>
            <button class="btn" onclick="goHome()" style="margin-top:20px; background:#333;">BACK</button>
        </div>

        <div id="scr-wait" class="screen">
            <h2 id="wait-msg">JOINING...</h2>
            <div id="lobby-count" style="color:#888; margin-top:10px;"></div>
            <button class="btn btn-ffa" style="background:#333; color:#fff;" onclick="goHome()">CANCEL</button>
        </div>
    </div>

    <div id="overlay-cnt" class="overlay hidden"><div id="cnt-txt">3</div></div>
    
    <div id="overlay-results" class="overlay hidden">
        <h1 style="color:#00ffcc;">RESULTS</h1>
        <table id="results-table">
            <thead><tr><th>#</th><th>PLAYER</th><th>APM</th><th>PPS</th><th>SENT</th><th>RECV</th></tr></thead>
            <tbody id="results-body"></tbody>
        </table>
        <div class="sub-txt" style="margin-top:20px; font-size:16px; color:#888;">Next round in <span id="res-timer">10</span>s...</div>
    </div>
    
    <div id="kill-feed"></div>
    <div id="chat-container" class="hidden">
        <div id="chat-header"><button id="chat-close" onclick="toggleChat()">X</button></div>
        <div id="chat-history"></div>
        <input type="text" id="chat-input" placeholder="Chat here..." onkeydown="sendChat(event)">
    </div>

    <div id="game-ui" class="game-area hidden">
        <div id="p1-root" class="player-root">
            <div class="stats-row">
                <div class="stat-box"><div class="stat-label">TIME</div><div id="s-time" class="stat-val">00:00</div></div>
                <div class="stat-box"><div class="stat-label">PPS</div><div id="s-pps" class="stat-val">0.00</div></div>
                <div class="stat-box"><div class="stat-label">APM</div><div id="s-apm" class="stat-val">0</div></div>
            </div>
            <div class="player-container">
                <div class="garbage-bar"><div id="p1-g" class="garbage-fill"></div></div>
                
                <div class="side-col">
                    <div class="side-box">HOLD<canvas id="p1-h" width="80" height="60"></canvas></div>
                    <div class="side-box">SENT<div id="s-sent" class="stat-val">0</div></div>
                    <div class="side-box">RECV<div id="s-recv" class="stat-val">0</div></div>
                </div>

                <div class="main-board-wrap">
                    <div id="p1-name" style="position:absolute; top:-25px; width:100%; text-align:center; color:#00e5ff; font-weight:bold;">YOU</div>
                    <canvas id="p1" width="120" height="900"></canvas>
                    
                    <div id="pop-action" class="float-text action-text">QUAD</div>
                    <div id="pop-combo" class="float-text combo-text">2 COMBO</div>
                    <div id="pop-b2b" class="float-text b2b-text">B2B</div>
                    <div id="pop-sent" class="float-text sent-text">+4</div>
                </div>

                <div class="side-col">
                    <div class="side-box" style="height:350px; justify-content: flex-start;">NEXT<canvas id="p1-n" width="80" height="320"></canvas></div>
                </div>
            </div>
        </div>
        <div id="ffa-grid"></div> </div>

    <script>
        // --- CONSTANTS ---
        // v1.4 UPDATE: ROWS set to 30 (4 Red Zone + 26 Safe Zone)
        const COLS=4, ROWS=30, B_SIZE=30; 
        
        // Piece shapes definition (I, O, T, S, Z, J, L)
        const PIECES=[[[1,1,1,1]],[[1,1],[1,1]],[[0,1,0],[1,1,1]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,0,0],[1,1,1]],[[0,0,1],[1,1,1]]];
        const COLORS=['#31C7EF','#F7D308','#FF69B4','#EF2029','#42B642','#9D00FF','#EF7921'];
        
        // --- SRS OFFSET DATA (WALL KICKS) ---
        // These tables define where the piece tries to move if rotation fails (kick data).
        const OFFSETS_JLSTZ = [
            [[0,0], [0,0], [0,0], [0,0], [0,0]], [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            [[0,0], [0,0], [0,0], [0,0], [0,0]], [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            [[0,0], [0,0], [0,0], [0,0], [0,0]], [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            [[0,0], [0,0], [0,0], [0,0], [0,0]], [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]]
        ];
        const OFFSETS_I = [
            [[0,0], [-1,0], [2,0], [-1,0], [2,0]], [[0,-1], [0,-1], [0,-1], [0,1], [0,-2]],
            [[-1,0], [0,0], [0,0], [0,1], [0,-2]], [[0,1], [0,1], [0,1], [0,-1], [0,2]],
            [[-1,1], [2,1], [-1,1], [2,0], [-1,0]], [[0,1], [0,1], [0,1], [0,-1], [0,2]],
            [[0,1], [0,1], [0,1], [0,-1], [0,2]], [[0,-1], [0,-1], [0,-1], [0,1], [0,-2]]
        ];
        const KICK_INDEX = { "0_1":0, "1_0":1, "1_2":2, "2_1":3, "2_3":4, "3_2":5, "3_0":6, "0_3":7 };

        // Global variables for game state
        let socket=null, gameActive=false, inputLocked=false, isSpectator=false;
        let gameMode='zen', startTime=0, apmTimer=null;
        let statsCache = {}; 
        
        // Auto-fill username/password if saved in LocalStorage
        window.onload = function() {
            if(localStorage.getItem('savedUser')) document.getElementById('username').value = localStorage.getItem('savedUser');
            if(localStorage.getItem('savedPass')) document.getElementById('password').value = localStorage.getItem('savedPass');
        };

        function saveCreds() {
            localStorage.setItem('savedUser', document.getElementById('username').value);
            localStorage.setItem('savedPass', document.getElementById('password').value);
        }

        // --- NAVIGATION & UI HELPERS ---
        function navTo(id) {
            document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function logOut() {
            localStorage.clear();
            document.getElementById('chat-container').classList.add('hidden'); 
            location.reload();
        }

        function toggleChat() {
            const chat = document.getElementById('chat-container');
            if (chat.style.display === 'none') chat.style.display = 'flex';
            else chat.style.display = 'none';
        }

        // Sends login credentials to server
        function attemptLogin() {
            const user = document.getElementById('username').value.trim();
            const pass = document.getElementById('password').value.trim();
            if(!user || !pass) return alert("Please enter Username and Password.");
            if(!socket) connect();
            socket.emit('login_attempt', { username: user, password: pass });
        }

        // Returns user to the main menu and resets game UI
        function goHome() {
            gameActive = false;
            clearTimeout(apmTimer);
            if (socket) socket.emit('leave_lobby');
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('home-btn').classList.add('hidden');
            document.getElementById('kill-feed').innerHTML = '';
            document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
            document.getElementById('menu-container').style.display = 'flex';
            navTo('scr-main');
        }

        function openStats() {
            if(!socket) return alert("Please login first.");
            socket.emit('request_all_stats');
            navTo('scr-stats');
        }

        // --- GAME MODES ---
        function startZen() {
            if(socket) socket.emit('leave_lobby'); 
            gameMode='zen';
            setupGameUI();
            p1.initRNG(Math.random()*999); p1.reset(); 
            gameActive = true; loop();
        }

        // APM Test: 60 seconds sprint
        function startAPMTest() {
            if(socket) socket.emit('leave_lobby'); 
            gameMode='apm_test';
            clearTimeout(apmTimer); 
            setupGameUI();
            p1.initRNG(Math.random()*999); p1.reset();
            gameActive = true; loop();
            
            // End game after 60 seconds
            apmTimer = setTimeout(() => {
                gameActive = false;
                const finalAPM = p1.elAPM.innerText;
                const winOver = document.getElementById('overlay-cnt'); 
                winOver.classList.remove('hidden');
                document.getElementById('cnt-txt').innerText = "FINISH";
                
                if(socket) socket.emit('submit_apm', finalAPM);
                setTimeout(goHome, 3000);
            }, 60000);
        }

        function joinFFA() {
            navTo('scr-wait');
            document.getElementById('wait-msg').innerText = "JOINING FFA LOBBY...";
            socket.emit('join_ffa');
        }

        function setupGameUI() {
            document.getElementById('menu-container').style.display = 'none';
            document.getElementById('game-ui').classList.remove('hidden');
            document.getElementById('home-btn').classList.remove('hidden');
        }

        // --- SOCKET.IO HANDLING ---
        function connect() {
            if(socket) return;
            socket = io();

            // Handle Login Response
            socket.on('login_response', data => {
                if(data.success) {
                    navTo('scr-main');
                    document.getElementById('display-user').innerText = data.username.toUpperCase();
                    document.getElementById('display-wins').innerText = data.wins;
                    document.getElementById('display-apm').innerText = data.bestAPM;
                    document.getElementById('chat-container').classList.remove('hidden'); 
                    document.getElementById('chat-container').style.display = 'flex';
                } else {
                    alert(data.msg);
                }
            });

            // Update Leaderboards (Wins & Combos)
            socket.on('leaderboard_update', data => {
                const winDiv = document.getElementById('lb-wins');
                winDiv.innerHTML = '';
                data.wins.forEach((p, i) => {
                    winDiv.innerHTML += `<div class="lb-item"><span>${i+1}. ${p.name}</span> <span>${p.val} W</span></div>`;
                });
                
                const cmbDiv = document.getElementById('lb-combo');
                cmbDiv.innerHTML = '';
                if(data.combos) {
                    data.combos.forEach((p, i) => {
                        cmbDiv.innerHTML += `<div class="lb-item"><span>${i+1}. ${p.name}</span> <span>${p.val} x</span></div>`;
                    });
                }
            });

            // Receive Data for Stats Page
            socket.on('receive_all_stats', data => {
                statsCache = data;
                const list = document.getElementById('stats-list');
                list.innerHTML = '';
                
                // Sort by Average APM logic
                const sortedUsers = Object.keys(data).sort((a,b) => {
                    const getAvg = (u) => {
                        const h = data[u].history || [];
                        if(!h.length) return 0;
                        return h.reduce((sum, x) => sum + (x.apm||0), 0) / h.length;
                    };
                    return getAvg(b) - getAvg(a);
                });

                sortedUsers.forEach(user => {
                    const h = data[user].history || [];
                    let avgAPM = 0;
                    if(h.length > 0) {
                        avgAPM = (h.reduce((sum, x) => sum + (x.apm||0), 0) / h.length).toFixed(0);
                    }
                    const div = document.createElement('div');
                    div.className = 'player-item';
                    div.innerHTML = `<span>${user}</span> <span style="color:#666">${avgAPM} APM</span>`;
                    div.onclick = () => showStatDetails(user);
                    list.appendChild(div);
                });
            });

            // Gameplay Sockets
            socket.on('start_countdown', data => {
                gameMode = 'ffa';
                setupGameUI();
                document.getElementById('overlay-results').classList.add('hidden'); 
                const ov = document.getElementById('overlay-cnt');
                const tx = document.getElementById('cnt-txt');
                ov.classList.remove('hidden');
                
                let n = data.duration;
                tx.innerText = n;
                inputLocked = true;
                
                const iv = setInterval(()=>{
                    n--;
                    if(n>0) tx.innerText = n;
                    else { clearInterval(iv); ov.classList.add('hidden'); }
                }, 1000);
            });

            socket.on('match_start', data => {
                inputLocked = false;
                gameMode = data.mode;
                isSpectator = false;
                setupOnlineGame(data.seed, data.players);
            });

            socket.on('receive_garbage', n => { if (gameMode === 'ffa' && !isSpectator) p1.receiveGarbage(n); });
            socket.on('enemy_board_update', d => { if (gameMode === 'ffa') drawEnemy(d.id, d.grid); });
            socket.on('elimination', d => { feed(`${d.username} eliminated!`); });
            socket.on('request_win_stats', () => { socket.emit('match_won', p1.getStats()); });
            
            socket.on('match_summary', results => {
                gameActive = false;
                const ov = document.getElementById('overlay-results');
                const tb = document.getElementById('results-body');
                tb.innerHTML = '';
                results.forEach(res => {
                    const row = `<tr><td class="${res.place===1?'rank-1':''}">${res.place}</td><td>${res.username}</td><td>${res.apm}</td><td>${res.pps}</td><td>${res.sent}</td><td>${res.recv}</td></tr>`;
                    tb.innerHTML += row;
                });
                ov.classList.remove('hidden');
                let t = 10;
                const sp = document.getElementById('res-timer');
                sp.innerText = t;
                const iv = setInterval(() => { t--; sp.innerText = t; if(t<=0) clearInterval(iv); }, 1000);
            });
            
            socket.on('lobby_reset', () => { document.getElementById('overlay-results').classList.add('hidden'); if(gameMode === 'ffa') goHome(); });
            socket.on('receive_chat', data => {
                const box = document.getElementById('chat-history');
                box.innerHTML += `<div class="chat-line"><span class="chat-user">${data.user}:</span> ${data.text}</div>`;
                box.scrollTop = box.scrollHeight;
            });
            socket.on('update_my_wins', w => document.getElementById('display-wins').innerText = w);
            socket.on('update_my_apm', a => document.getElementById('display-apm').innerText = a);
            socket.on('ffa_spectate', d => {
                document.getElementById('wait-msg').innerText = "SPECTATING...";
                setTimeout(() => { isSpectator=true; gameMode='ffa'; setupGameUI(); setupOnlineGame(d.seed, d.players); }, 1000);
            });
        }

        // --- STATS LOGIC ---
        function showStatDetails(user) {
            const d = statsCache[user];
            const div = document.getElementById('stats-detail');
            let avgAPM=0, avgPPS=0, avgSent=0, avgRecv=0, games=d.history.length;
            if (games > 0) {
                avgAPM = (d.history.reduce((a,b)=>a+(b.apm||0), 0) / games).toFixed(1);
                avgPPS = (d.history.reduce((a,b)=>a+parseFloat(b.pps||0), 0) / games).toFixed(2);
                avgSent = (d.history.reduce((a,b)=>a+(b.sent||0), 0) / games).toFixed(1);
                avgRecv = (d.history.reduce((a,b)=>a+(b.received||0), 0) / games).toFixed(1);
            }
            let html = `<h2 style="color:#00a8ff">${user.toUpperCase()}</h2>`;
            html += `<div style="display:flex; gap:20px; margin-bottom:20px;">
                <div class="stat-box"><div>WINS</div><div class="stat-val">${d.wins}</div></div>
                <div class="stat-box"><div>MAX COMBO</div><div class="stat-val">${d.bestCombo || 0}</div></div>
            </div>`;
            html += `<h3 style="text-align:left; color:#888;">AVERAGES</h3><div style="display:flex; gap:10px; margin-bottom:20px;">
                <div class="stat-box"><div>APM</div><div class="stat-val">${avgAPM}</div></div>
                <div class="stat-box"><div>PPS</div><div class="stat-val">${avgPPS}</div></div>
                <div class="stat-box"><div>SENT</div><div class="stat-val">${avgSent}</div></div>
                <div class="stat-box"><div>RECV</div><div class="stat-val">${avgRecv}</div></div>
            </div>`;
            html += `<h3>HISTORY</h3><table class="history-table"><thead><tr><th>DATE</th><th>PLACE</th><th>APM</th><th>PPS</th><th>SENT</th><th>CMB</th></tr></thead><tbody>`;
            [...d.history].reverse().forEach(h => {
                const date = new Date(h.date).toLocaleDateString();
                html += `<tr><td>${date}</td><td style="color:${h.place===1?'#ffcc00':'#fff'}">${h.place}</td><td>${h.apm}</td><td>${h.pps}</td><td>${h.sent}</td><td>${h.maxCombo||0}</td></tr>`;
            });
            html += `</tbody></table>`;
            div.innerHTML = html;
        }

        // --- GAME ENGINE ---
        function setupOnlineGame(seed, players) {
            gameActive = true;
            p1.initRNG(seed); p1.reset();
            const grid = document.getElementById('ffa-grid');
            grid.innerHTML = '';
            players.forEach(p => {
                if(p.id !== socket.id) {
                    const d = document.createElement('div');
                    d.className = 'mini-card';
                    d.innerHTML = `<div style="font-size:10px; color:#888">${p.username}</div><canvas id="cvs_${p.id}" width="80" height="520"></canvas>`;
                    grid.appendChild(d);
                }
            });
            document.getElementById('p1-root').style.opacity = isSpectator ? '0.3' : '1';
            loop();
        }

        function drawEnemy(id, grid) {
            const cvs = document.getElementById(`cvs_${id}`);
            if(!cvs) return;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,80,520);
            if(grid) grid.forEach((r,y)=>r.forEach((v,x)=>{ if(v){ ctx.fillStyle=v; ctx.fillRect(x*20,y*20,19,19); } }));
        }

        function feed(msg) {
            const f = document.getElementById('kill-feed');
            const d = document.createElement('div');
            d.className='feed-msg'; d.innerText=msg;
            f.appendChild(d); setTimeout(()=>d.remove(),4000);
        }

        function sendChat(e) {
            if(e.key === 'Enter') {
                const input = document.getElementById('chat-input');
                const txt = input.value.trim();
                if(txt && socket) { socket.emit('send_chat', txt); input.value = ''; }
            }
        }

        // --- PLAYER LOGIC (MAIN CLASS) ---
        class SeededRNG { constructor(s){this.s=s;} next(){this.s=(this.s*9301+49297)%233280;return this.s/233280;} }
        
        class Player {
            constructor(){
                this.ctx=document.getElementById('p1').getContext('2d');
                this.nCtx=document.getElementById('p1-n').getContext('2d');
                this.hCtx=document.getElementById('p1-h').getContext('2d');
                this.gBar=document.getElementById('p1-g');
                this.elSent=document.getElementById('s-sent');
                this.elRecv=document.getElementById('s-recv');
                this.elTime=document.getElementById('s-time');
                this.elPPS=document.getElementById('s-pps');
                this.elAPM=document.getElementById('s-apm');
                this.popAct=document.getElementById('pop-action');
                this.popCmbo=document.getElementById('pop-combo');
                this.popB2B=document.getElementById('pop-b2b');
                this.popSent=document.getElementById('pop-sent');

                this.rotation = 0;
                this.grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
                this.bag=[]; this.queue=[]; this.holdId=null; this.canHold=true;
                this.pendingG=0; this.combo=-1; this.maxCombo=0; this.b2b=0; 
                this.dropCounter=0; this.lockTimer=0; this.dasTimer=0; this.arrTimer=0;
                this.piecesPlaced=0; this.linesSentTotal=0; this.linesRecvTotal=0;
                this.rng=new SeededRNG(1);
                this.startTime = Date.now();
            }
            
            getStats() {
                const sec = (Date.now() - this.startTime) / 1000;
                return {
                    apm: (sec>0 ? Math.floor((this.linesSentTotal/sec)*60) : 0),
                    pps: (sec>0 ? (this.piecesPlaced/sec).toFixed(2) : "0.00"),
                    sent: this.linesSentTotal, recv: this.linesRecvTotal, maxCombo: this.maxCombo 
                };
            }

            initRNG(s){this.rng=new SeededRNG(s);}
            reset(){ 
                this.grid.forEach(r=>r.fill(0)); 
                this.bag=[]; this.queue=[]; 
                this.piecesPlaced=0; this.linesSentTotal=0; this.linesRecvTotal=0; this.pendingG=0;
                this.startTime = Date.now();
                this.holdId = null; this.canHold = true; this.maxCombo = 0; this.rotation = 0;
                this.drawSide(this.hCtx, [this.holdId]);
                for(let i=0;i<4;i++)this.queue.push(this.pull()); 
                this.spawn(); 
            }
            pull(){ if(!this.bag.length){this.bag=[0,1,2,3,4,5,6]; for(let i=6;i>0;i--){const j=Math.floor(this.rng.next()*(i+1));[this.bag[i],this.bag[j]]=[this.bag[j],this.bag[i]];}} return this.bag.pop(); }
            
            spawn(id=this.queue.shift()){
                this.queue.push(this.pull());
                this.rotation = 0;
                // v1.2 FIX: Spawn position to x=0 for 4-wide board
                this.active={pos:{x:0, y:-1}, matrix:PIECES[id], id:id, color:COLORS[id]};
                
                this.lastMoveRotate=false;
                this.lockTimer = 0;
                
                // Spawn collision check (Death handled in Lock() via Red Zone)
                if(this.collide()){}
                this.drawSide(this.nCtx,this.queue); this.sendBoard();
            }

            collide(m=this.active.matrix, p=this.active.pos) {
                for(let y=0; y<m.length; y++) {
                    for(let x=0; x<m[y].length; x++) {
                        if(m[y][x]) {
                            const gx = x + p.x;
                            const gy = y + p.y;
                            if (gx < 0 || gx >= COLS) return true; 
                            if (gy >= ROWS) return true; 
                            if (gy >= 0 && this.grid[gy][gx]) return true; 
                        }
                    }
                }
                return false;
            }

            // v1.3 UPDATE: SMALL BOARD KICKS
            rotate(dir=1) { 
                const currentRot = this.rotation;
                let nextRot = (currentRot + dir + 4) % 4; 
                const nextMatrix = this.active.matrix[0].map((_,i) => this.active.matrix.map(row => row[i]).reverse());
                const isI = (this.active.id === 0); 
                const isO = (this.active.id === 1);
                if (isO) return; 

                const kickTable = isI ? OFFSETS_I : OFFSETS_JLSTZ;
                const kickRowIndex = KICK_INDEX[`${currentRot}_${nextRot}`];
                const kicks = kickTable[kickRowIndex];
                const initialPos = { x: this.active.pos.x, y: this.active.pos.y };

                // 1. Standard SRS
                for (let i = 0; i < kicks.length; i++) {
                    const offset = kicks[i];
                    this.active.pos.x = initialPos.x + offset[0];
                    this.active.pos.y = initialPos.y - offset[1]; 
                    if (!this.collide(nextMatrix, this.active.pos)) {
                        this.applyRotation(nextMatrix, nextRot); return;
                    }
                }

                // 2. Extra Safety Kicks for 4-wide board
                const safetyKicks = [[-1,0],[1,0],[-2,0],[2,0],[-3,0]];
                for(let k of safetyKicks) {
                    this.active.pos.x = initialPos.x + k[0];
                    this.active.pos.y = initialPos.y + k[1];
                    if (!this.collide(nextMatrix, this.active.pos)) {
                        this.applyRotation(nextMatrix, nextRot); return;
                    }
                }

                // Fail
                this.active.pos.x = initialPos.x;
                this.active.pos.y = initialPos.y;
            }

            applyRotation(matrix, rot) {
                this.active.matrix = matrix;
                this.rotation = rot;
                this.lastMoveRotate = true;
                if(this.isGrounded()) this.lockTimer = 0;
                this.sendBoard();
            }

            move(d){ 
                this.active.pos.x+=d; 
                if(this.collide()) this.active.pos.x-=d; 
                else { this.lastMoveRotate=false; if(this.isGrounded()) this.lockTimer=0; this.sendBoard(); } 
            }
            isGrounded() { this.active.pos.y++; const hit=this.collide(); this.active.pos.y--; return hit; }
            hardDrop(){ while(!this.collide())this.active.pos.y++; this.active.pos.y--; this.lock(); }
            hold(){ 
                if(!this.canHold)return; 
                const c=this.active.id; 
                if(this.holdId===null){this.holdId=c;this.spawn();} else{const t=this.holdId;this.holdId=c;this.spawn(t);} 
                this.canHold=false; this.drawSide(this.hCtx,[this.holdId]); 
            }
            
            lock(){
                let entirelyInRed = true; // v1.3: Red Zone death tracking
                
                this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{ 
                    if(v) { 
                        const gy=y+this.active.pos.y; 
                        if(gy>=0) {
                            this.grid[gy][x+this.active.pos.x]=this.active.color; 
                            // v1.3: If any block locks below row 3, we are safe
                            if (gy >= 4) entirelyInRed = false;
                        }
                    } 
                }));
                this.piecesPlaced++;
                const linesCleared = this.sweep(); 
                
                // v1.3: Game Over if locked entirely in Red Zone (rows 0-3) with no line clear
                if (entirelyInRed && linesCleared === 0) {
                     if(gameMode !== 'zen' && gameMode !== 'apm_test' && socket) {
                        socket.emit('player_died', this.getStats()); 
                        isSpectator=true; document.getElementById('p1-root').style.opacity='0.3';
                        return;
                    } else {
                        this.reset();
                        return;
                    }
                }

                this.canHold=true; this.spawn();
            }

            sweep(){
                let lines=0, isPC=true;
                for(let y=ROWS-1;y>=0;y--){ if(this.grid[y].every(v=>v!==0)){this.grid.splice(y,1);this.grid.unshift(Array(COLS).fill(0));lines++;y++;} else if(this.grid[y].some(v=>v!==0)) isPC=false; }
                
                if(lines>0){
                    this.combo++;
                    if(this.combo > this.maxCombo) this.maxCombo = this.combo;
                    let atk=0, txt="";
                    txt=(lines==1)?"SINGLE":(lines==2)?"DOUBLE":(lines==3)?"TRIPLE":"QUAD"; atk=(lines==4)?4:(lines-1); 
                    if(isPC){ txt="ALL CLEAR"; atk+=10; }
                    this.showText(this.popAct, txt);
                    if(lines==4){ this.b2b++; if(this.b2b>1){atk+=1; this.showText(this.popB2B, "B2B x"+(this.b2b-1));} } else this.b2b=0;
                    if(this.combo>0){ atk+=Math.floor((this.combo-1)/2); this.showText(this.popCmbo, this.combo+" COMBO"); }
                    if(atk > 0) this.showText(this.popSent, `+${atk}`);
                    if(this.pendingG>0){ let c=Math.min(this.pendingG,atk); this.pendingG-=c; atk-=c; }
                    this.linesSentTotal+=atk; 
                    if(atk>0 && (gameMode === 'ffa')){ if(socket && !isSpectator) socket.emit('send_garbage', {mode:gameMode, amount:atk}); }
                } else {
                    this.combo=-1;
                    while(this.pendingG>0){ this.pendingG--; const r=Array(COLS).fill('#555'); r[Math.floor(Math.random()*COLS)]=0; this.grid.shift(); this.grid.push(r); }
                }
                this.gBar.style.height=(this.pendingG*30)+'px';
                this.updateStats();
                return lines; // Return lines for Red Zone check
            }

            receiveGarbage(n){ this.pendingG+=n; this.linesRecvTotal+=n; this.gBar.style.height=(this.pendingG*30)+'px'; this.updateStats(); }
            
            updateStats(){
                const sec = (Date.now() - this.startTime) / 1000;
                this.elSent.innerText = this.linesSentTotal;
                this.elRecv.innerText = this.linesRecvTotal;
                this.elPPS.innerText = (sec>0 ? (this.piecesPlaced/sec).toFixed(2) : "0.00");
                this.elAPM.innerText = (sec>0 ? Math.floor((this.linesSentTotal/sec)*60) : 0);
                let displaySec = sec;
                if(gameMode === 'apm_test') displaySec = 60 - sec; 
                if(displaySec < 0) displaySec = 0;
                const m=Math.floor(displaySec/60).toString().padStart(2,'0');
                const s=Math.floor(displaySec%60).toString().padStart(2,'0');
                this.elTime.innerText = `${m}:${s}`;
            }

            drawSide(ctx, ids){
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ids.forEach((id, i) => {
                    if (id !== null) {
                        ctx.fillStyle = COLORS[id];
                        const shape = PIECES[id];
                        const pw = shape[0].length * 20;
                        const ph = shape.length * 20;
                        const ox = (ctx.canvas.width - pw) / 2;
                        const oy = i * 80 + (80-ph)/2;
                        shape.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value) ctx.fillRect(ox + x * 20, oy + y * 20, 19, 19);
                            });
                        });
                    }
                });
            }
            
            sendBoard(){ if(socket && !isSpectator){ const d=JSON.parse(JSON.stringify(this.grid)); this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{if(v&&d[y+this.active.pos.y])d[y+this.active.pos.y][x+this.active.pos.x]=this.active.color;})); socket.emit('update_board',d); } }
            showText(el, msg){ el.innerText=msg; el.style.opacity=1; setTimeout(()=>el.style.opacity=0, 1000); }
            
            update(dt){
                this.dropCounter+=dt;
                if(this.dropCounter > 700) {
                    this.active.pos.y++;
                    if(this.collide()) { this.active.pos.y--; } else { this.lockTimer = 0; this.lastMoveRotate = false; }
                    this.dropCounter = 0;
                }
                if(this.isGrounded()) { this.lockTimer += dt; if(this.lockTimer > 500) this.lock(); }
                this.sendBoard();
            }

            draw(){
                // v1.4 UPDATE: Clear 900px height
                this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,120,900);
                
                // v1.3 UPDATE: Draw Red Zone (Rows 0-3)
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                this.ctx.fillRect(0, 0, 120, 120); 
                
                // Draw Grid
                this.grid.forEach((r,y)=>r.forEach((v,x)=>{if(v){this.ctx.fillStyle=v; this.ctx.fillRect(x*B_SIZE,y*B_SIZE,B_SIZE-1,B_SIZE-1);}}));
                // Draw Active Piece
                if(this.active && !isSpectator){
                    let g={...this.active.pos}; while(!this.collide(this.active.matrix,g))g.y++; g.y--;
                    this.ctx.fillStyle='rgba(255,255,255,0.15)'; this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{if(v)this.ctx.fillRect((g.x+x)*B_SIZE,(g.y+y)*B_SIZE,B_SIZE-1,B_SIZE-1);}));
                    this.ctx.fillStyle=this.active.color; this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{if(v)this.ctx.fillRect((this.active.pos.x+x)*B_SIZE,(this.active.pos.y+y)*B_SIZE,B_SIZE-1,B_SIZE-1);}));
                }
            }
        }

        const p1 = new Player();
        const keys = new Set();
        const ctrl = {left:'ArrowLeft',right:'ArrowRight',rotate:'ArrowUp',soft:'ArrowDown',hard:'Space',hold:'ShiftLeft'};
        
        window.addEventListener('keydown', e=>{
            if(gameMode === 'zen' || gameMode === 'apm_test') {
                if(document.activeElement.tagName !== 'INPUT' && e.code === 'KeyR') {
                    if(gameMode === 'zen') startZen();
                    if(gameMode === 'apm_test') startAPMTest();
                    return;
                }
            }
            if(!inputLocked && gameActive && !isSpectator){
                if(["Space","ArrowUp","ArrowDown"].includes(e.code)) e.preventDefault();
                if(!keys.has(e.code)){
                    keys.add(e.code);
                    if(e.code==ctrl.rotate)p1.rotate();
                    if(e.code==ctrl.hold)p1.hold();
                    if(e.code==ctrl.hard)p1.hardDrop();
                    if(e.code==ctrl.left || e.code==ctrl.right){ p1.dasTimer=0; p1.arrTimer=0; p1.move(e.code==ctrl.left?-1:1); }
                }
            }
        });
        window.addEventListener('keyup', e=>keys.delete(e.code));

        let lastT=0;
        function loop(t=0){
            const dt=t-lastT; lastT=t;
            if(gameActive) {
                if(!isSpectator && !inputLocked){
                    if(keys.has(ctrl.soft)){ p1.active.pos.y++; if(p1.collide())p1.active.pos.y--; else { p1.lastMoveRotate=false; p1.lockTimer=0; } }
                    if(keys.has(ctrl.left)||keys.has(ctrl.right)){
                        const d=keys.has(ctrl.left)?-1:1;
                        p1.dasTimer+=dt;
                        if(p1.dasTimer>130){ p1.arrTimer+=dt; if(p1.arrTimer>0){ p1.move(d); p1.arrTimer=0; } }
                    }
                    p1.update(dt);
                    p1.updateStats();
                }
                p1.draw();
            }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
